##类型转换

JavaScript 是*弱类型*语言，所以会在**任何**可能的情况下应用*强制类型转换*。

    // 下面的比较结果是：true
    new Number(10) == 10; // Number.toString() 返回的字符串被再次转换为数字

    10 == '10';           // 字符串被转换为数字
    10 == '+10 ';         // 同上
    10 == '010';          // 同上 
    isNaN(null) == false; // null 被转换为数字 0
                          // 0 当然不是一个 NaN（译者注：否定之否定）
    
    // 下面的比较结果是：false
    10 == 010;
    10 == '-10';

> **ES5 提示:** 以 `0` 开头的数字字面值会被作为八进制数字解析。
> 而在 ECMAScript 5 严格模式下，这个特性被**移除**了。

为了避免上面复杂的强制类型转换，**强烈**推荐使用[严格的等于操作符](#types.equality)。
虽然这可以避免大部分的问题，但 JavaScript 的弱类型系统仍然会导致一些其它问题。

###内置类型的构造函数

内置类型（比如 `Number` 和 `String`）的构造函数在被调用时，使用或者不使用 `new` 的结果完全不同。

    new Number(10) === 10;     // False, 对象与数字的比较
    Number(10) === 10;         // True, 数字与数字的比较
    new Number(10) + 0 === 10; // True, 由于隐式的类型转换

使用内置类型 `Number` 作为构造函数将会创建一个新的 `Number` 对象，
而在不使用 `new` 关键字的 `Number` 函数更像是一个数字转换器。

另外，在比较中引入对象的字面值将会导致更加复杂的强制类型转换。

最好的选择是把要比较的值**显式**的转换为三种可能的类型之一。

###转换为字符串

    '' + 10 === '10'; // true

将一个值加上空字符串可以轻松转换为字符串类型。

###转换为数字

    +'10' === 10; // true

使用**一元**的加号操作符，可以把字符串转换为数字。

**[译者注][30]：**字符串转换为数字的常用方法：

	+'010' === 10
	Number('010') === 10
	parseInt('010', 10) === 10  // 用来转换为整数

	+'010.2' === 10.2
	Number('010.2') === 10.2
	parseInt('010.2', 10) === 10

	
###转换为布尔型

通过使用 **否** 操作符两次，可以把一个值转换为布尔型。

    !!'foo';   // true
    !!'';      // false
    !!'0';     // true
    !!'1';     // true
    !!'-1'     // true
    !!{};      // true
    !!true;    // true

[30]: http://cnblogs.com/sanshi/
